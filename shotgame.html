<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>瓦罗兰特练枪 - 道具加强版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #8FBC8F;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.05s;
        }
        
        /* 红色受伤闪屏 */
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background-color: #00ff00;
            border: 1px solid rgba(0,0,0,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 2px #000;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(0, 255, 0, 0.8);
        }
        #crosshair::before { top: 2px; left: -6px; width: 18px; height: 2px; }
        #crosshair::after { top: -6px; left: 2px; width: 2px; height: 18px; }

        #hud {
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 50px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        /* 警告提示 */
        #warning-msg {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            color: #ff3333;
            font-weight: 900;
            text-shadow: 0 0 10px black;
            opacity: 0;
            transition: opacity 0.2s;
            text-transform: uppercase;
        }

        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            color: #0ff;
            font-size: 48px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            text-align: center;
        }

        p {
            color: #eee;
            font-size: 18px;
            margin-bottom: 30px;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
        }
        .legend-item { display: flex; align-items: center; gap: 10px; color: white; font-size: 14px; }
        .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; }

        button {
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            background: linear-gradient(45deg, #ff4655, #d62e3d);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 70, 85, 0.6);
        }

        .hidden { display: none !important; }

        .result-line {
            font-size: 30px;
            color: #fff;
            margin: 5px 0;
        }
        #final-score { color: #0ff; font-size: 60px; margin: 10px 0; }
        #accuracy { color: #ffd700; }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="flash-overlay"></div>
        <div id="damage-overlay"></div>
        <div id="hud">
            <div class="stat-box">时间: <span id="timer">30</span>s</div>
            <div class="stat-box">分数: <span id="score">0</span></div>
        </div>
        <div id="warning-msg">警告：导弹来袭！按空格跳跃！</div>
        <div id="crosshair"></div>
    </div>

    <audio id="bgm" loop>
        <source src="https://cdn.pixabay.com/audio/2022/03/15/audio_a66f61f947.mp3" type="audio/mp3">
    </audio>

    <div id="menu">
        <h1 id="menu-title">瓦罗兰特 靶场模拟</h1>
        <p>
            <b>全新机制：</b><br>
            <span style="color:#00FFFF">蓝色球</span>：击杀得分。<br>
            <span style="color:#FFD700">金色球 (高空)</span>：奖励 <b>+5s</b>。<br>
            <span style="color:#FF0000">红色球 (地雷)</span>：扣除 <b>-5s</b>。<br>
            <span style="color:#AAAAAA">导弹来袭</span>：按 <b>空格(Space)</b> 跳跃躲避，否则 <b>-10s</b>。
        </p>
        
        <div id="results-area" class="hidden" style="text-align: center; margin-bottom: 20px;">
            <div id="final-score" class="result-line">0</div>
            <div id="accuracy" class="result-line">命中率: 0%</div>
        </div>

        <button id="start-btn">开始练习</button>
    </div>

    <script>
        // --- 游戏配置 ---
        const CONFIG = {
            duration: 30,
            targetRadius: 0.3, 
            spawnDistance: 10, 
            playerHeight: 1.6, 
            bgColor: 0x88cc88, 
            targetColor: 0x00FFFF, // 蓝
            bonusColor: 0xFFD700,  // 金
            mineColor: 0xFF0000,   // 红
            missileColor: 0x333333,// 灰
            maxTargets: 4, // 稍微增加目标数，因为有地雷混淆
            fov: 75,
            shrinkSpeed: 0.4,
            spawnRangeAngle: 90,
            recoilAmount: 0.002,
            shakeIntensity: 0.02,
            gravity: 20, // 重力
            jumpForce: 8, // 跳跃力度
            mineChance: 0.2, // 生成地雷的概率
            bonusChance: 0.1 // 生成奖励的概率 (每次刷怪时)
        };

        // --- 全局变量 ---
        let camera, scene, renderer, controls;
        let targets = [];
        let missiles = []; // 导弹数组
        let particles = [];
        let shockwaves = [];
        let raycaster;
        let score = 0;
        let shotsFired = 0;
        let timeLeft = CONFIG.duration;
        let isPlaying = false;
        let lastTime = performance.now();
        let gameInterval;
        
        // 物理状态
        let velocityY = 0;
        let canJump = false;
        let currentShake = 0;

        const bgm = document.getElementById('bgm');
        bgm.volume = 0.3;

        let isLocked = false;
        const menu = document.getElementById('menu');
        const startBtn = document.getElementById('start-btn');
        const scoreEl = document.getElementById('score');
        const timerEl = document.getElementById('timer');
        const menuTitle = document.getElementById('menu-title');
        const resultsArea = document.getElementById('results-area');
        const finalScoreEl = document.getElementById('final-score');
        const accuracyEl = document.getElementById('accuracy');
        const flashOverlay = document.getElementById('flash-overlay');
        const damageOverlay = document.getElementById('damage-overlay');
        const warningMsg = document.getElementById('warning-msg');

        // --- 音效合成器 ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const t = audioCtx.currentTime;

            if (type === 'shoot') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.1);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.start();
                osc.stop(t + 0.15);
            } else if (type === 'hit') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, t);
                osc.frequency.exponentialRampToValueAtTime(1200, t + 0.05);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                osc.start();
                osc.stop(t + 0.3);
            } else if (type === 'bonus') {
                // 高亮清脆音效
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(1200, t);
                osc.frequency.linearRampToValueAtTime(1800, t + 0.1);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);
                osc.start();
                osc.stop(t + 0.3);
            } else if (type === 'bad') {
                // 低沉错误音效
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.linearRampToValueAtTime(100, t + 0.3);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);
                osc.start();
                osc.stop(t + 0.3);
            } else if (type === 'jump') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.linearRampToValueAtTime(300, t + 0.2);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.start();
                osc.stop(t + 0.2);
            }

            osc.connect(gain);
            gain.connect(audioCtx.destination);
        }

        // --- 指针锁定控件 ---
        class PointerLockControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
                this.PI_2 = Math.PI / 2;
                this.sensitivity = 0.002;
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
            }

            onMouseMove(event) {
                if (!isLocked) return;
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                this.euler.setFromQuaternion(this.camera.quaternion);
                this.euler.y -= movementX * this.sensitivity;
                this.euler.x -= movementY * this.sensitivity;
                this.euler.x = Math.max(-this.PI_2, Math.min(this.PI_2, this.euler.x));
                this.camera.quaternion.setFromEuler(this.euler);
            }
            
            addRecoil(x, y) {
                this.euler.setFromQuaternion(this.camera.quaternion);
                this.euler.x += x; 
                this.euler.y += y; 
                this.euler.x = Math.max(-this.PI_2, Math.min(this.PI_2, this.euler.x));
                this.camera.quaternion.setFromEuler(this.euler);
            }
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.bgColor);
            scene.fog = new THREE.Fog(CONFIG.bgColor, 10, 40);

            camera = new THREE.PerspectiveCamera(CONFIG.fov, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = CONFIG.playerHeight;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);

            addEnvironment();

            controls = new PointerLockControls(camera, document.body);

            startBtn.addEventListener('click', () => document.body.requestPointerLock());

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === document.body) {
                    isLocked = true;
                    if (!isPlaying) startGame();
                    if (isPlaying) bgm.play(); 
                    menu.classList.add('hidden');
                } else {
                    isLocked = false;
                    if (isPlaying) {
                        bgm.pause();
                        menu.classList.remove('hidden');
                        menuTitle.textContent = "已暂停";
                        startBtn.textContent = "继续";
                        resultsArea.classList.add('hidden');
                    }
                }
            });

            document.addEventListener('mousedown', (event) => {
                if (isLocked && isPlaying && event.button === 0) {
                    shoot();
                }
            });

            // 跳跃监听
            document.addEventListener('keydown', (event) => {
                if (isLocked && isPlaying && event.code === 'Space') {
                    if (canJump) {
                        velocityY = CONFIG.jumpForce;
                        canJump = false;
                        playSound('jump');
                    }
                }
            });

            raycaster = new THREE.Raycaster();
            window.addEventListener('resize', onWindowResize, false);
        }

        function addEnvironment() {
            const gridHelper = new THREE.GridHelper(100, 100, 0xffffff, 0x558855);
            gridHelper.position.y = 0;
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // 90度边界线
            const rangeRad = (CONFIG.spawnRangeAngle / 2) * (Math.PI / 180);
            const lineLen = CONFIG.spawnDistance + 5;
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xFFFF00, opacity: 0.8, transparent: true });
            const points = [
                new THREE.Vector3(0, 0.05, 0),
                new THREE.Vector3(Math.sin(-rangeRad) * lineLen, 0.05, -Math.cos(-rangeRad) * lineLen),
                new THREE.Vector3(0, 0.05, 0),
                new THREE.Vector3(Math.sin(rangeRad) * lineLen, 0.05, -Math.cos(rangeRad) * lineLen)
            ];
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            const rangeLines = new THREE.LineSegments(lineGeo, lineMaterial);
            scene.add(rangeLines);

            const ceilingGeo = new THREE.PlaneGeometry(100, 100);
            const ceilingMat = new THREE.MeshBasicMaterial({ color: 0x77aa77, side: THREE.DoubleSide });
            const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 12; // 提高天花板给奖励球空间
            scene.add(ceiling);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(0, 10, 0);
            scene.add(dirLight);
        }

        function startGame() {
            score = 0;
            shotsFired = 0;
            timeLeft = CONFIG.duration;
            isPlaying = true;
            scoreEl.innerText = score;
            timerEl.innerText = timeLeft;
            resultsArea.classList.add('hidden');
            warningMsg.style.opacity = 0;
            
            bgm.currentTime = 0;
            bgm.play().catch(e => console.log("Audio Error:", e));

            menuTitle.textContent = "瓦罗兰特 靶场模拟";
            menuTitle.style.color = "";
            startBtn.textContent = "开始练习";

            targets.forEach(t => scene.remove(t));
            targets = [];
            missiles.forEach(m => scene.remove(m));
            missiles = [];
            shockwaves.forEach(s => scene.remove(s));
            shockwaves = [];

            // 初始生成
            for(let i=0; i<CONFIG.maxTargets; i++) spawnTarget(false);

            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(() => {
                if (!isPlaying || !isLocked) return;
                
                timeLeft--;
                timerEl.innerText = timeLeft;
                
                // 随机生成导弹 (约每8秒一次)
                if (timeLeft > 2 && Math.random() < 0.15 && missiles.length === 0) {
                    spawnMissile();
                }

                if (timeLeft <= 0) endGame();
            }, 1000);
        }

        function endGame() {
            isPlaying = false;
            clearInterval(gameInterval);
            document.exitPointerLock();
            bgm.pause();

            menu.classList.remove('hidden');
            if (score > 20) {
                menuTitle.innerHTML = "神射手！<br>牛逼！";
                menuTitle.style.color = "#00ff00";
            } else {
                menuTitle.innerHTML = "废物<br>菜就多练";
                menuTitle.style.color = "#ff4655";
            }
            
            let accuracy = 0;
            if (shotsFired > 0) {
                accuracy = Math.round((score / shotsFired) * 100);
            }

            finalScoreEl.textContent = `最终得分: ${score}`;
            accuracyEl.textContent = `命中率: ${accuracy}%`;
            resultsArea.classList.remove('hidden');
            startBtn.textContent = "再来一次";
        }

        function spawnTarget(allowSpecial = true) {
            if (targets.length >= CONFIG.maxTargets) return;

            let type = 'normal';
            let radius = CONFIG.targetRadius;
            let color = CONFIG.targetColor;
            let posY = CONFIG.playerHeight; // 默认爆头线

            // 概率判定特殊物品
            if (allowSpecial) {
                const rand = Math.random();
                if (rand < CONFIG.bonusChance) {
                    type = 'bonus';
                    color = CONFIG.bonusColor;
                    radius = 0.2; // 更小
                    posY = 4 + Math.random() * 2; // 高空 (4-6米)
                } else if (rand < CONFIG.bonusChance + CONFIG.mineChance) {
                    type = 'mine';
                    color = CONFIG.mineColor;
                }
            }

            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const sphere = new THREE.Mesh(geometry, material);

            // 位置逻辑
            const halfAngle = CONFIG.spawnRangeAngle / 2;
            const angle = (Math.random() * CONFIG.spawnRangeAngle - halfAngle) * (Math.PI / 180); 
            const distance = CONFIG.spawnDistance + (Math.random() * 2 - 1); 

            sphere.position.x = Math.sin(angle) * distance;
            sphere.position.z = -Math.cos(angle) * distance;
            sphere.position.y = posY;

            sphere.scale.set(0,0,0);
            sphere.userData = { 
                isSpawning: true, 
                scaleSpeed: 0.1, 
                type: type 
            };

            scene.add(sphere);
            targets.push(sphere);
        }

        function spawnMissile() {
            const geometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
            geometry.rotateX(Math.PI / 2); // 旋转使圆柱体横向
            const material = new THREE.MeshBasicMaterial({ color: CONFIG.missileColor });
            const missile = new THREE.Mesh(geometry, material);

            // 从正前方远处生成
            const startDist = 30;
            missile.position.set(0, 1, -startDist); // 高度1，需要跳跃躲避
            missile.userData = { speed: 15 }; // 飞行速度

            scene.add(missile);
            missiles.push(missile);

            // UI 警告
            warningMsg.style.opacity = 1;
            setTimeout(() => warningMsg.style.opacity = 0, 2000);
        }

        function applyTimeChange(amount) {
            timeLeft += amount;
            if (amount > 0) {
                timerEl.style.color = "#00ff00"; // 绿色增益
                setTimeout(() => timerEl.style.color = "white", 500);
            } else {
                timerEl.style.color = "#ff0000"; // 红色惩罚
                damageOverlay.style.opacity = 0.3;
                setTimeout(() => {
                    timerEl.style.color = "white";
                    damageOverlay.style.opacity = 0;
                }, 300);
                // 震动
                currentShake = 0.2; 
            }
            timerEl.innerText = Math.max(0, timeLeft);
        }

        function createShockwave(position) {
            const geometry = new THREE.RingGeometry(0.1, 0.2, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF, transparent: true, opacity: 0.8, side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.position.copy(position);
            ring.lookAt(camera.position);
            ring.userData = { expandSpeed: 4, fadeSpeed: 2 };
            scene.add(ring);
            shockwaves.push(ring);
        }

        function createExplosion(position, color) {
            const particleCount = 20;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions.push(position.x, position.y, position.z);
                velocities.push(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ 
                color: color, size: 0.15, transparent: true 
            });

            const particleSystem = new THREE.Points(geometry, material);
            particleSystem.userData = { velocities: velocities, age: 0 };
            scene.add(particleSystem);
            particles.push(particleSystem);
        }

        function triggerScreenFlash() {
            flashOverlay.style.opacity = '0.2';
            setTimeout(() => flashOverlay.style.opacity = '0', 50);
        }

        function shoot() {
            shotsFired++;
            playSound('shoot');
            controls.addRecoil(CONFIG.recoilAmount, (Math.random() - 0.5) * CONFIG.recoilAmount * 0.5);
            currentShake = CONFIG.shakeIntensity;

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const hitObject = intersects[0].object;
                const type = hitObject.userData.type;

                createExplosion(hitObject.position, hitObject.material.color);
                createShockwave(hitObject.position);
                
                scene.remove(hitObject);
                targets = targets.filter(t => t !== hitObject);

                if (type === 'bonus') {
                    playSound('bonus');
                    applyTimeChange(5);
                } else if (type === 'mine') {
                    playSound('bad');
                    applyTimeChange(-5);
                    // 地雷不加分
                } else {
                    // 普通目标
                    score++;
                    scoreEl.innerText = score;
                    playSound('hit');
                    triggerScreenFlash();
                }

                spawnTarget(true);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - lastTime) / 1000, 0.1); // 防止过大 delta
            lastTime = time;

            if (!isPlaying) return;

            // --- 物理与跳跃 ---
            velocityY -= CONFIG.gravity * delta;
            camera.position.y += velocityY * delta;

            if (camera.position.y <= CONFIG.playerHeight) {
                camera.position.y = CONFIG.playerHeight;
                velocityY = 0;
                canJump = true;
            }

            // --- 震动逻辑 ---
            let shakeOffsetX = 0;
            let shakeOffsetY = 0;
            if (currentShake > 0) {
                shakeOffsetX = (Math.random() - 0.5) * currentShake;
                shakeOffsetY = (Math.random() - 0.5) * currentShake;
                currentShake -= delta * 1.0;
                if(currentShake < 0) currentShake = 0;
            }
            // 将震动叠加在物理位置上
            camera.position.x = shakeOffsetX;
            // 注意：y轴震动需要叠加在当前的跳跃高度上，不能直接覆盖
            const actualY = camera.position.y; 
            camera.position.y = actualY + shakeOffsetY;


            // --- 导弹逻辑 ---
            for (let i = missiles.length - 1; i >= 0; i--) {
                const m = missiles[i];
                m.position.z += m.userData.speed * delta;
                m.rotation.z += 5 * delta; // 旋转特效

                // 碰撞检测
                // 简单距离检测: 玩家在 (0, camera.y, 0), 导弹在 (0, 1, z)
                // 如果导弹 z > -0.5 (靠近玩家) 且 z < 0.5 且 玩家高度 < 2.0 (没跳起来)
                if (m.position.z > -0.5 && m.position.z < 0.5) {
                    if (camera.position.y < 2.2) { // 判定是否跳起躲避
                        // 撞到了
                        playSound('bad');
                        applyTimeChange(-10);
                        scene.remove(m);
                        missiles.splice(i, 1);
                        continue;
                    }
                }

                // 超出屏幕移除
                if (m.position.z > 5) {
                    scene.remove(m);
                    missiles.splice(i, 1);
                }
            }

            // --- 目标逻辑 ---
            for (let i = targets.length - 1; i >= 0; i--) {
                const t = targets[i];
                if (t.userData.isSpawning) {
                    if (t.scale.x < 1) {
                        t.scale.addScalar(t.userData.scaleSpeed); 
                    } else {
                        t.scale.set(1,1,1);
                        t.userData.isSpawning = false;
                    }
                } else {
                    // 缩小
                    t.scale.subScalar(CONFIG.shrinkSpeed * delta);
                    if (t.scale.x <= 0.05) {
                        scene.remove(t);
                        targets.splice(i, 1);
                        spawnTarget(true); 
                    }
                }
                // 如果是高空奖励球，加一点上下浮动动画
                if (t.userData.type === 'bonus') {
                    t.position.y += Math.sin(time * 0.005) * 0.01;
                }
            }

            // --- 粒子与特效 ---
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.userData.age += delta;
                const positions = p.geometry.attributes.position.array;
                const vel = p.userData.velocities;
                for (let j = 0; j < positions.length; j += 3) {
                    positions[j] += vel[j];
                    positions[j+1] += vel[j+1];
                    positions[j+2] += vel[j+2];
                }
                p.geometry.attributes.position.needsUpdate = true;
                p.material.opacity = 1 - (p.userData.age / 0.5); 
                if (p.userData.age >= 0.5) { scene.remove(p); particles.splice(i, 1); }
            }

            for (let i = shockwaves.length - 1; i >= 0; i--) {
                const s = shockwaves[i];
                s.scale.addScalar(s.userData.expandSpeed * delta);
                s.material.opacity -= s.userData.fadeSpeed * delta;
                if (s.material.opacity <= 0) { scene.remove(s); shockwaves.splice(i, 1); }
            }

            renderer.render(scene, camera);
            
            // 渲染后恢复Y轴位置，以免震动叠加导致位置漂移
            camera.position.y = actualY;
        }
    </script>
</body>
</html>